[{"categories":null,"content":"\rHttpClient を用いて API 通信を行う","date":"2024-03-10","objectID":"/blazor_intro/:0:0","series":null,"tags":null,"title":"Blazor WebAssemblyでAPI通信を行う","uri":"/blazor_intro/#httpclient-を用いて-api-通信を行う"},{"categories":null,"content":"\rはじめに筆者は現在 Blazor を勉強しており、登竜門である API 通信を行ってみます。 動作環境は以下の通りです。 ツール 名称 PC Windows11 エディタ Visual Studio 2022 ","date":"2024-03-10","objectID":"/blazor_intro/:1:0","series":null,"tags":null,"title":"Blazor WebAssemblyでAPI通信を行う","uri":"/blazor_intro/#はじめに"},{"categories":null,"content":"\r1.Controller クラスの作成本記事は書籍『ドメイン駆動設計入門 ボトムアップでわかる! ドメイン駆動設計の基本』に基づき、以下のフォルダ構成で開発を行います。 Controller エンドポイントを設定 Service 業務ロジックを定義 Repository DB アクセスロジックを定義 Model バインド対象のモデルを定義 では、実際にコードを記述していきましょう。 namespace Sample.Controllers { [ApiController] [Route(\"api/[controller]\")] public class UserController : ControllerBase { public IUserService userService; public UserController(IUserService userService) { this.userService = userService; } [HttpGet] public async Task\u003cActionResult\u003cIEnumerable\u003cUser\u003e\u003e\u003e Get() { var results = await userService.GetUsers(); return Ok(result); } [HttpPost, Route(\"{id}\")] public async Task\u003cActionResult\u003cUser\u003e\u003e Post(string id) { var result = await userService.GetUser(id); return Ok(result); } } } ここで、IUserServiceクラスはまだ定義していませんが、処理の流れを決めるために、先に記述しておきます。 ","date":"2024-03-10","objectID":"/blazor_intro/:2:0","series":null,"tags":null,"title":"Blazor WebAssemblyでAPI通信を行う","uri":"/blazor_intro/#1controller-クラスの作成"},{"categories":null,"content":"\rController クラスController クラスは API のエンドポイントの役割を果たします。 ApiController 属性を Controller クラスに適用することで、以下の API 固有の動作を提供できます。 属性ルーティング要件 自動的な HTTP 400 応答 バインディングソース属性 マルチパート/フォーム データ要求の推論 属性ルーティング要件属性ルーティング要件とは、コードの[Route(\"api/[controller]\")]の部分です。 この場合だと、[controller]の部分はUserControllerのUserの部分がマッピングされます。 自動的な HTTP400 応答モデル検証エラーが発生すると HTTP 400 応答が自動的にトリガーされます。 その結果、アクション メソッド内でステータスコード 400 を入れる処理が不要になります。 バインディングソース属性バインディング ソース属性では、アクション パラメーターの値が存在する場所が定義されます。 次のバインディング ソース属性が存在します。 属性 バインド ソース [FromBody] 要求本文 [FromForm] 要求本文内のフォーム データ [FromHeader] 要求ヘッダー [FromQuery] 要求のクエリ文字列パラメーター [FromRoute] 現在の要求からのルート データ [FromServices] アクション パラメーターとして挿入される要求サービス [AsParameters] メソッドのパラメーター 今回の場合は、Postメソッド内で引数idを渡していますが、属性が省略されています。 この場合は、ASP.NET Core ランタイムにより複合オブジェクト モデル バインダーの使用が試行されます。 複合オブジェクト モデル バインダーでは、値プロバイダーから定義された順序でデータを取得します。 マルチパート/フォーム データ要求の推論[ApiController] 属性を設定すると、IFormFile および IFormFileCollection 型のアクション パラメーターに対して推論規則が適用されます。 multipart/form-data 要求コンテンツ タイプは、これらの種類に対して推論されます。 ","date":"2024-03-10","objectID":"/blazor_intro/:2:1","series":null,"tags":null,"title":"Blazor WebAssemblyでAPI通信を行う","uri":"/blazor_intro/#controller-クラス"},{"categories":null,"content":"\rController クラスController クラスは API のエンドポイントの役割を果たします。 ApiController 属性を Controller クラスに適用することで、以下の API 固有の動作を提供できます。 属性ルーティング要件 自動的な HTTP 400 応答 バインディングソース属性 マルチパート/フォーム データ要求の推論 属性ルーティング要件属性ルーティング要件とは、コードの[Route(\"api/[controller]\")]の部分です。 この場合だと、[controller]の部分はUserControllerのUserの部分がマッピングされます。 自動的な HTTP400 応答モデル検証エラーが発生すると HTTP 400 応答が自動的にトリガーされます。 その結果、アクション メソッド内でステータスコード 400 を入れる処理が不要になります。 バインディングソース属性バインディング ソース属性では、アクション パラメーターの値が存在する場所が定義されます。 次のバインディング ソース属性が存在します。 属性 バインド ソース [FromBody] 要求本文 [FromForm] 要求本文内のフォーム データ [FromHeader] 要求ヘッダー [FromQuery] 要求のクエリ文字列パラメーター [FromRoute] 現在の要求からのルート データ [FromServices] アクション パラメーターとして挿入される要求サービス [AsParameters] メソッドのパラメーター 今回の場合は、Postメソッド内で引数idを渡していますが、属性が省略されています。 この場合は、ASP.NET Core ランタイムにより複合オブジェクト モデル バインダーの使用が試行されます。 複合オブジェクト モデル バインダーでは、値プロバイダーから定義された順序でデータを取得します。 マルチパート/フォーム データ要求の推論[ApiController] 属性を設定すると、IFormFile および IFormFileCollection 型のアクション パラメーターに対して推論規則が適用されます。 multipart/form-data 要求コンテンツ タイプは、これらの種類に対して推論されます。 ","date":"2024-03-10","objectID":"/blazor_intro/:2:1","series":null,"tags":null,"title":"Blazor WebAssemblyでAPI通信を行う","uri":"/blazor_intro/#属性ルーティング要件"},{"categories":null,"content":"\rController クラスController クラスは API のエンドポイントの役割を果たします。 ApiController 属性を Controller クラスに適用することで、以下の API 固有の動作を提供できます。 属性ルーティング要件 自動的な HTTP 400 応答 バインディングソース属性 マルチパート/フォーム データ要求の推論 属性ルーティング要件属性ルーティング要件とは、コードの[Route(\"api/[controller]\")]の部分です。 この場合だと、[controller]の部分はUserControllerのUserの部分がマッピングされます。 自動的な HTTP400 応答モデル検証エラーが発生すると HTTP 400 応答が自動的にトリガーされます。 その結果、アクション メソッド内でステータスコード 400 を入れる処理が不要になります。 バインディングソース属性バインディング ソース属性では、アクション パラメーターの値が存在する場所が定義されます。 次のバインディング ソース属性が存在します。 属性 バインド ソース [FromBody] 要求本文 [FromForm] 要求本文内のフォーム データ [FromHeader] 要求ヘッダー [FromQuery] 要求のクエリ文字列パラメーター [FromRoute] 現在の要求からのルート データ [FromServices] アクション パラメーターとして挿入される要求サービス [AsParameters] メソッドのパラメーター 今回の場合は、Postメソッド内で引数idを渡していますが、属性が省略されています。 この場合は、ASP.NET Core ランタイムにより複合オブジェクト モデル バインダーの使用が試行されます。 複合オブジェクト モデル バインダーでは、値プロバイダーから定義された順序でデータを取得します。 マルチパート/フォーム データ要求の推論[ApiController] 属性を設定すると、IFormFile および IFormFileCollection 型のアクション パラメーターに対して推論規則が適用されます。 multipart/form-data 要求コンテンツ タイプは、これらの種類に対して推論されます。 ","date":"2024-03-10","objectID":"/blazor_intro/:2:1","series":null,"tags":null,"title":"Blazor WebAssemblyでAPI通信を行う","uri":"/blazor_intro/#自動的な-http400-応答"},{"categories":null,"content":"\rController クラスController クラスは API のエンドポイントの役割を果たします。 ApiController 属性を Controller クラスに適用することで、以下の API 固有の動作を提供できます。 属性ルーティング要件 自動的な HTTP 400 応答 バインディングソース属性 マルチパート/フォーム データ要求の推論 属性ルーティング要件属性ルーティング要件とは、コードの[Route(\"api/[controller]\")]の部分です。 この場合だと、[controller]の部分はUserControllerのUserの部分がマッピングされます。 自動的な HTTP400 応答モデル検証エラーが発生すると HTTP 400 応答が自動的にトリガーされます。 その結果、アクション メソッド内でステータスコード 400 を入れる処理が不要になります。 バインディングソース属性バインディング ソース属性では、アクション パラメーターの値が存在する場所が定義されます。 次のバインディング ソース属性が存在します。 属性 バインド ソース [FromBody] 要求本文 [FromForm] 要求本文内のフォーム データ [FromHeader] 要求ヘッダー [FromQuery] 要求のクエリ文字列パラメーター [FromRoute] 現在の要求からのルート データ [FromServices] アクション パラメーターとして挿入される要求サービス [AsParameters] メソッドのパラメーター 今回の場合は、Postメソッド内で引数idを渡していますが、属性が省略されています。 この場合は、ASP.NET Core ランタイムにより複合オブジェクト モデル バインダーの使用が試行されます。 複合オブジェクト モデル バインダーでは、値プロバイダーから定義された順序でデータを取得します。 マルチパート/フォーム データ要求の推論[ApiController] 属性を設定すると、IFormFile および IFormFileCollection 型のアクション パラメーターに対して推論規則が適用されます。 multipart/form-data 要求コンテンツ タイプは、これらの種類に対して推論されます。 ","date":"2024-03-10","objectID":"/blazor_intro/:2:1","series":null,"tags":null,"title":"Blazor WebAssemblyでAPI通信を行う","uri":"/blazor_intro/#バインディングソース属性"},{"categories":null,"content":"\rController クラスController クラスは API のエンドポイントの役割を果たします。 ApiController 属性を Controller クラスに適用することで、以下の API 固有の動作を提供できます。 属性ルーティング要件 自動的な HTTP 400 応答 バインディングソース属性 マルチパート/フォーム データ要求の推論 属性ルーティング要件属性ルーティング要件とは、コードの[Route(\"api/[controller]\")]の部分です。 この場合だと、[controller]の部分はUserControllerのUserの部分がマッピングされます。 自動的な HTTP400 応答モデル検証エラーが発生すると HTTP 400 応答が自動的にトリガーされます。 その結果、アクション メソッド内でステータスコード 400 を入れる処理が不要になります。 バインディングソース属性バインディング ソース属性では、アクション パラメーターの値が存在する場所が定義されます。 次のバインディング ソース属性が存在します。 属性 バインド ソース [FromBody] 要求本文 [FromForm] 要求本文内のフォーム データ [FromHeader] 要求ヘッダー [FromQuery] 要求のクエリ文字列パラメーター [FromRoute] 現在の要求からのルート データ [FromServices] アクション パラメーターとして挿入される要求サービス [AsParameters] メソッドのパラメーター 今回の場合は、Postメソッド内で引数idを渡していますが、属性が省略されています。 この場合は、ASP.NET Core ランタイムにより複合オブジェクト モデル バインダーの使用が試行されます。 複合オブジェクト モデル バインダーでは、値プロバイダーから定義された順序でデータを取得します。 マルチパート/フォーム データ要求の推論[ApiController] 属性を設定すると、IFormFile および IFormFileCollection 型のアクション パラメーターに対して推論規則が適用されます。 multipart/form-data 要求コンテンツ タイプは、これらの種類に対して推論されます。 ","date":"2024-03-10","objectID":"/blazor_intro/:2:1","series":null,"tags":null,"title":"Blazor WebAssemblyでAPI通信を行う","uri":"/blazor_intro/#マルチパートフォーム-データ要求の推論"},{"categories":null,"content":"\r2.Service クラスの作成","date":"2024-03-10","objectID":"/blazor_intro/:3:0","series":null,"tags":null,"title":"Blazor WebAssemblyでAPI通信を行う","uri":"/blazor_intro/#2service-クラスの作成"},{"categories":null,"content":"\rService クラスService クラスはユースケースを実現するために使用されます。今回の場合ではユーザーのデータを操作するので、ユーザー取得、更新、削除といったユースケースを作成します。 同じように、コードを記述していきましょう。 namespace Sample.Services { public class UserService : IUserService { public IUserRepository userRepository; public UserService(IUserRepository userRepository) { this.userRepository = userRepository; } public async Task\u003cActionResult\u003cIEnumerable\u003cUser\u003e\u003e\u003e Get() { return await userRepository.GetUsers(); } public async Task\u003cActionResult\u003cUser\u003e\u003e Post(string id) { return await userService.GetUser(id); } } } 先ほど Controller クラスで定義したUserServiceクラスとなります。 同じように、IUserRepositoryクラスはまだ定義していませんが、後に実装します。 本来であれば、ビジネスロジックや複雑なユースケースを実現するのですが、今回は簡単な CRUD 処理のため、簡潔な処理のみとなっています。 ","date":"2024-03-10","objectID":"/blazor_intro/:3:1","series":null,"tags":null,"title":"Blazor WebAssemblyでAPI通信を行う","uri":"/blazor_intro/#service-クラス"},{"categories":null,"content":"\r3.Repository クラスの作成さいごに Repository クラスの作成です。 Repository クラスではドメインオブジェクトの永続化や再構築を行うクラスです。 簡単に説明すると、DB の処理をラップするクラスです。 同じように、コードを記述していきましょう。 namespace Sample.Repositories { public class UserRepository : IUserRepository { public async Task\u003cActionResult\u003cIEnumerable\u003cUser\u003e\u003e\u003e Get() { using(var connection = new SqlConnection(ConnectionStrings)) using(var command = connection.createCommand()) { connection.Open(); var sql = \"SELECT * FROM M_USER\"; var results = connection.Query\u003cUser\u003e(sql); return results; } } } } このように、DB から取得したデータを Service クラスに渡す役割を果たします。 以上の 3 クラスを利用することで、API 通信を行うための前段階が出来ました。 ","date":"2024-03-10","objectID":"/blazor_intro/:4:0","series":null,"tags":null,"title":"Blazor WebAssemblyでAPI通信を行う","uri":"/blazor_intro/#3repository-クラスの作成"},{"categories":null,"content":"\r4. razor ファイルの実装ここで、Blazor の Client 側である razor ファイルの記述を行っていきます。 Blazor はその特徴から、Client 側と Server 側の両方が C#で記述できます。 それではコードを記述していきましょう。 @inject HttpClient Http @if(users is not null) { \u003cul\u003e @foreach (var user in users) { \u003cli\u003e@user.UserId\u003c/li\u003e } \u003c/ul\u003e } @code { private IEnumerable\u003cUser\u003e users = Enumerable.Empty\u003cUser\u003e; protected override async Task OnInitializedAsync(){ users = await Http.GetFromJsonAsync\u003cIEnumerable\u003cUser\u003e\u003c/User\u003e\u003e(\"api/user\"); } } Blazor では HttpClient がデフォルトで用意されているので、それをinjectディレクティブを用いてサービスをコンポーネントに挿入します。 あとはエンドポイントに合わせてメソッドを呼び出すだけです。今回はGETメソッドを用いてユーザー情報を取得しているので、GetFromJsonAsyncメソッドを用います。 これで API 通信を用いてデータを画面に表示することができました。 ","date":"2024-03-10","objectID":"/blazor_intro/:5:0","series":null,"tags":null,"title":"Blazor WebAssemblyでAPI通信を行う","uri":"/blazor_intro/#4-razor-ファイルの実装"},{"categories":null,"content":"\rさいごにBlazor を用いて API 通信を行ってみました。 まだまだ細かい理解ができていない部分が多いので、分かり次第記述していきます。 ","date":"2024-03-10","objectID":"/blazor_intro/:6:0","series":null,"tags":null,"title":"Blazor WebAssemblyでAPI通信を行う","uri":"/blazor_intro/#さいごに"},{"categories":null,"content":"\r参考文献https://learn.microsoft.com/ja-jp/aspnet/core/blazor/call-web-api?view=aspnetcore-7.0\u0026pivots=webassembly https://learn.microsoft.com/ja-jp/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#conventional-routing ","date":"2024-03-10","objectID":"/blazor_intro/:7:0","series":null,"tags":null,"title":"Blazor WebAssemblyでAPI通信を行う","uri":"/blazor_intro/#参考文献"},{"categories":null,"content":"\rはじめにCSS を何気なく使っているが、プロパティの違いを言語化できていないので、 QA 形式で言語化していく。 ","date":"2024-03-02","objectID":"/my-first-post/:1:0","series":null,"tags":null,"title":"CSSのプロパティについて言語化する","uri":"/my-first-post/#はじめに"},{"categories":null,"content":"\rCSS の QA 集\rdisplay で inline と inline-block の違いは？inline-block では width や height が設定できるのに対し、inline では width や height は設定できない。 また、inline-block では上下左右の margin が設定できるのに対し、inline では左右の margin しか設定できない。 rem と em の違いは？em は親要素のサイズを基準にするのに対し、rem はルート要素のサイズを基準にします。 –webkit とは？Webkit エンジンを搭載したブラウザ(Chrome、Safari)などで独自のプロパティや機能を使用するためのベンダー接頭辞である。 Webkit プロパティの優先度について あくまで非推奨な機能のため、できるだけ使用しない方がよい。 ","date":"2024-03-02","objectID":"/my-first-post/:1:1","series":null,"tags":null,"title":"CSSのプロパティについて言語化する","uri":"/my-first-post/#css-の-qa-集"},{"categories":null,"content":"\rCSS の QA 集\rdisplay で inline と inline-block の違いは？inline-block では width や height が設定できるのに対し、inline では width や height は設定できない。 また、inline-block では上下左右の margin が設定できるのに対し、inline では左右の margin しか設定できない。 rem と em の違いは？em は親要素のサイズを基準にするのに対し、rem はルート要素のサイズを基準にします。 –webkit とは？Webkit エンジンを搭載したブラウザ(Chrome、Safari)などで独自のプロパティや機能を使用するためのベンダー接頭辞である。 Webkit プロパティの優先度について あくまで非推奨な機能のため、できるだけ使用しない方がよい。 ","date":"2024-03-02","objectID":"/my-first-post/:1:1","series":null,"tags":null,"title":"CSSのプロパティについて言語化する","uri":"/my-first-post/#display-で-inline-と-inline-block-の違いは"},{"categories":null,"content":"\rCSS の QA 集\rdisplay で inline と inline-block の違いは？inline-block では width や height が設定できるのに対し、inline では width や height は設定できない。 また、inline-block では上下左右の margin が設定できるのに対し、inline では左右の margin しか設定できない。 rem と em の違いは？em は親要素のサイズを基準にするのに対し、rem はルート要素のサイズを基準にします。 –webkit とは？Webkit エンジンを搭載したブラウザ(Chrome、Safari)などで独自のプロパティや機能を使用するためのベンダー接頭辞である。 Webkit プロパティの優先度について あくまで非推奨な機能のため、できるだけ使用しない方がよい。 ","date":"2024-03-02","objectID":"/my-first-post/:1:1","series":null,"tags":null,"title":"CSSのプロパティについて言語化する","uri":"/my-first-post/#rem-と-em-の違いは"},{"categories":null,"content":"\rCSS の QA 集\rdisplay で inline と inline-block の違いは？inline-block では width や height が設定できるのに対し、inline では width や height は設定できない。 また、inline-block では上下左右の margin が設定できるのに対し、inline では左右の margin しか設定できない。 rem と em の違いは？em は親要素のサイズを基準にするのに対し、rem はルート要素のサイズを基準にします。 –webkit とは？Webkit エンジンを搭載したブラウザ(Chrome、Safari)などで独自のプロパティや機能を使用するためのベンダー接頭辞である。 Webkit プロパティの優先度について あくまで非推奨な機能のため、できるだけ使用しない方がよい。 ","date":"2024-03-02","objectID":"/my-first-post/:1:1","series":null,"tags":null,"title":"CSSのプロパティについて言語化する","uri":"/my-first-post/#--webkit-とは"}]